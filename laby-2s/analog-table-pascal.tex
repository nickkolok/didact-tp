\begin{table}[ph]

\begin{tabular}{|l|l|m{8cm}|}
\hline
			Паскаль
&
			C++
&
			Пояснение
\\\hline
			\barecodesnippet{code-snippets/analog-begin.pas}{language=Pascal}
&
			\barecodesnippet{code-snippets/analog-begin.cpp}{language=C++}
&
	\multirow{2}{8cm}{
			Открывающая и закрывающая операторные скобки соответственно.
			Позволяют группировать другие операторы в циклах и т. д.
	}
\\[0.2cm]\cline{1-2}
			\barecodesnippet{code-snippets/analog-end.pas}{language=Pascal}
&
			\barecodesnippet{code-snippets/analog-end.cpp}{language=C++}
&
\\[0.2cm]\hline
			\barecodesnippet{code-snippets/analog-var.pas}{language=Pascal}
&
			\barecodesnippet{code-snippets/analog-var.cpp}{language=C++}
&
			В C++, в отличие от Паскаля, переменные можно объявлять почти в любом месте программы,
			а не обязательно в специальном блоке перед \textbf{begin}.
\\\hline
			\barecodesnippet{code-snippets/analog-read.pas}{language=Pascal}
&
			\barecodesnippet{code-snippets/analog-read.cpp}{language=C++}
&
			Можно вводить переменные как по одной, так и <<цепочками из воронок>>.
\\\hline
			\barecodesnippet{code-snippets/analog-write.pas}{language=Pascal}
&
			\barecodesnippet{code-snippets/analog-write.cpp}{language=C++}
&
			Выводить переменные тоже можно и поодиночке, и <<цепочками из воронок>>.
\\\hline
			\barecodesnippet{code-snippets/analog-writeln.pas}{language=Pascal}
&
			\barecodesnippet{code-snippets/analog-writeln.cpp}{language=C++}
&
			За перевод строки отвечает манипулятор потока \textbf{endl}.
			После него тоже можно ставить <<воронку>>:
			\textbf{cout <~\!\!\!< a <~\!\!\!< endl <~\!\!\!< b;}
			Здесь между значениями \textbf{a} и \textbf{b} будет перевод строки.
			Вместо \textbf{endl} можно использовать \textbf{"\textbackslash{n}"}.
\\\hline
			\barecodesnippet{code-snippets/analog-assignment.pas}{language=Pascal}
&
			\barecodesnippet{code-snippets/analog-assignment.cpp}{language=C++}
&
			В Паскале присваивание производится знаком \textbf{:=}~~,
			а в C++ одинарным знаком равенства.
			Важно не путать!
\\\hline
			\barecodesnippet{code-snippets/analog-comparison.pas}{language=Pascal}
&
			\barecodesnippet{code-snippets/analog-comparison.cpp}{language=C++}
&
			В Паскале сравнение производится одинарным знаком равенства,
			а в C++ двойным.
			Важно не путать!
\\\hline
			\barecodesnippet{code-snippets/analog-comment.pas}{language=Pascal}
&
			\barecodesnippet{code-snippets/analog-comment.cpp}{language=C++}
&
			Первый вариант называется многострочным комментарием, второй --- однострочным
			(всё, что после \textbf{//} и до конца строки --- комментарий,
			то есть компьютером не читается и нужно лишь для удобства человека)
\\\hline
			\barecodesnippet{code-snippets/analog-if-else.pas}{language=Pascal}
&
			\barecodesnippet{code-snippets/analog-if-else.cpp}{language=C++}
&
			Условный оператор (ветвление).
			Обратите внимание на то, что для сравнения переменных в условии в С++ используется запись
			\textbf{a==b}, а для присваивания --- запись \textbf{c=0}.
			Условие в C++ следует заключать в скобки.
			Аналог \textbf{then} отсутствует.
\\\hline
			\barecodesnippet{code-snippets/analog-for.pas}{language=Pascal}
&
			\barecodesnippet{code-snippets/analog-for.cpp}{language=C++}
&
			Цикл со счётчиком.
			Обратите внимание на сокращённое присваивание:
			\textbf{i++} означает \textbf{i=i+1}, а
			\textbf{s+=i} означает \textbf{s=s+i}
\\\hline
			\barecodesnippet{code-snippets/analog-while.pas}{language=Pascal}
&
			\barecodesnippet{code-snippets/analog-while.cpp}{language=C++}
&
			Цикл с условием (с предусловием).
			Делает то же самое, что и предыдущий, кроме присваивания \textbf{i} начального значения.
			Условие в C++ следует заключать в скобки.
\\\hline
\end{tabular}

\end{table}
