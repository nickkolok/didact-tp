#include <iostream>
#include <cmath>

using namespace std;

int main () {
	double epsilon = 0.0001;

	// Считаем сумму ряда \sum_{i=1}^{\infty} \frac{sin i}{i^2}
	// с точностью epsilon

	double sum;

	sum = 0; // Не забыть инициализировать!
	int i; // Если объявить в цикле, будет недоступна после выполнения цикла
	for (i = 1; ; i++) {// Приравнивание тоже можно вынести, будет for (; ; i++)
		// Цикл запускаем с единицы (по условию)
		// Обратите внимание: цикл - он не всегда с нуля!
		double delta = sin(i)/(i*i);
		if(abs(delta)<epsilon) { //abs - это модуль, важно не забыть!
			break; // Прерываем выполнение цикла
		}
		// else писать не нужно - break в случае выполнения условия
		// и так передал управление вне цикла
		sum += delta;
	}
	cout << "Сумма " << i << " слагаемых равна " << sum << endl;

	// То же, но через while
	sum = 0; // Не забыть инициализировать!
	i = 1;
	double delta; // Если объявить в цикле, будет недоступна в условии

	while (abs(delta = sin(i)/(i*i)) >= epsilon) {// Присваивание прямо под знаком модуля
		sum += delta;
		i++;
	}
	cout << "Сумма " << i << " слагаемых равна " << sum << endl;

	// while с постфиксным инкрементом - работает неправильно
	sum = 0; // Не забыть обнулить!
	i = 1;
	//double delta; // Второй раз не объявляем

	while (abs(delta = sin(i++)/(i*i)) >= epsilon) {
		// Компилятор выдаёт предупреждение: в одном выражении i++ и использование i
		// Что вычисляется сначала: sin(i++) или (i*i) - непонятно
		// Это пример того, как НЕ надо использовать инкремент
		sum += delta;
	}
	cout << "Сумма " << i << " слагаемых равна " << sum << endl;

	// Наконец - адский for-однострочник
	for (sum = 0, i = 1; abs(delta = sin(i)/(i*i)) >= epsilon; sum += delta, i++) {}
	// Два присваивания можно написать через запятую, выполнятся оба.
	// Но в реальной работе так делать не стОит.

	cout << "Сумма " << i << " слагаемых равна " << sum << endl;

	return 0;
}
