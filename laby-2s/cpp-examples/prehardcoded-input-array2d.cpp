/*
С клавиатуры вводится массив из 5 строк и 3 столбцов и число n.
Выведите на экран сумму элементов n-й строки массива.
*/

#include <iostream>
using namespace std;
int main(){

	/* Раскомментировать после отладки
	// {{ "Честный" ввод
	cout << "Введите массив:" << endl;
	int mas[5][3];
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 3; j++) {
			cin >> mas[i][j];
		}
	}
	// }} "Честный" ввод
	*/

	// {{ Отладочная фиксация - удалить в конце отладки
	// Так можно писать только вместе с объявлением массива!
	int mas[5][3] = { // Лучше выравнивать именно так
		10, 11, 12,
		20, 21, 22,
		30, 31, 32,
		40, 41, 42,
		50, 51, 52, // Последняя запятая - обычно не страшно, можно смело её писать
	};
	// Если нужно два варианта - комментируем блочно: /* ... */
	/*
	int mas[5][3] = { // Не надо стесняться красиво выровнять матрицу
		-10,  11,  12,
		{20, -21},      // Третий элемент считается равным нулю
		 30,  31, -32,
		 40, -41,  42,
		// Отсутствующие строки тоже обнуляются
	};
	*/
	// На каждый вариант - отдельный блок-комментарий, так удобнее

	// Если массив объявлен "с запасом", удобно сочетать эти приёмы:
	/*
	int mas[5][3] = {
		{-10,  11},
		{ 20, -21},
		{ 30,  31},
	};
	// Если вдруг это не работает (а такое бывает, например, при некоторых способах
	// доступа к массиву через указатели), уберите внутренние фигурные скобки
	*/
	// }} Отладочная фиксация

	// Не обязательно фиксировать всё, можно только трудоёмкие массивы
	cout << "Введите номер строки:" << endl;
	int n;
	cin >> n;

	// {{ Вывод массива
	cout << "Исходный массив:" << endl;
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 3; j++) {
			cout << mas[i][j] << " ";
		}
		cout << endl;
	}
	cout << endl;
	// }} Вывод массива

	// {{ Подсчёт суммы
	int sum = mas[n][0];
	for (int j = 1; j < 3; j++) {
		sum += mas[n][j];
	}
	// }} Подсчёт суммы
	cout << "Сумма элементов " << n << "-й строки равна " << sum << endl;

	cout << endl;
	return 0;
}
